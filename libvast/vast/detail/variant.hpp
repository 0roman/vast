// Copyright (C) 2013 Jarryd Beck
//
// (adapted by Matthias Vallentin for C++17 conformance).
//
// Distributed under the Boost Software License, Version 1.0
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
//   The copyright notices in the Software and this entire statement, including
//   the above license grant, this restriction and the following disclaimer,
//   must be included in all copies of the Software, in whole or in part, and
//   all derivative works of the Software, unless such copies or derivative
//   works are solely in the form of machine-executable object code generated by
//   a source language processor.
//
//   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//   FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
//   SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
//   FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
//   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//   DEALINGS IN THE SOFTWARE.

#ifndef VAST_DETAIL_VARIANT_HPP
#define VAST_DETAIL_VARIANT_HPP

#include <functional>
#include <map>
#include <memory>
#include <set>
#include <string>
#include <tuple>
#include <type_traits>

#include <caf/meta/load_callback.hpp>
#include <caf/meta/save_callback.hpp>

#include <caf/detail/scope_guard.hpp>

#include "vast/detail/assert.hpp"
#include "vast/detail/type_traits.hpp"

#include "vast/util/operators.hpp"

namespace vast {
namespace detail {

template <class Visitor>
class delayed_visitor {
public:
  delayed_visitor(Visitor v) : visitor(std::move(v)) {
  }

  template <class... Visitables>
  auto operator()(Visitables&&... vs) {
    return visit(visitor, std::forward<Visitables>(vs)...);
  }

private:
  Visitor visitor;
};

template <class Visitor>
class delayed_visitor_wrapper {
public:
  delayed_visitor_wrapper(Visitor& visitor) : visitor(visitor) {
  }

  template <class... Visitables>
  auto operator()(Visitables&&... vs) {
    return visit(visitor, std::forward<Visitables>(vs)...);
  }

private:
  Visitor& visitor;
};

template <class Visitor, class Visitable>
class binary_visitor {
public:
  binary_visitor(Visitor& arg_visitor, Visitable& arg_visitable)
    : visitor(arg_visitor), visitable(arg_visitable) {
  }

  template <class... Ts>
  auto operator()(Ts&&... xs) {
    return visitable.template apply(visitor, std::forward<Ts>(xs)...);
  }

private:
  Visitor& visitor;
  Visitable& visitable;
};

/// A variant class modeled after C++17's variant.
/// @tparam Ts the types the variant should assume.
template <class... Ts>
class variant : util::totally_ordered<variant<Ts...>> {
public:
  using types = std::tuple<Ts...>;
  using first_type = std::tuple_element_t<0, types>;

  /// Default-construct a variant with the first type.
  variant() noexcept(std::is_nothrow_default_constructible<first_type>::value) {
    construct(first_type{});
    index_ = 0;
  }

   /// Destruct variant by invoking destructor of the active instance.
  ~variant() noexcept {
    destruct();
  }

  template <class T, class = disable_if_same_or_derived_t<variant, T>>
  variant(T&& x) {
    // A compile error here means that T is not unambiguously convertible to
    // any of the variant types.
    initializer<0, Ts...>::initialize(*this, std::forward<T>(x));
  }

  variant(const variant& other) {
    other.apply(copy_constructor{*this});
    index_ = other.index_;
  }

  variant(variant&& other) noexcept {
    other.apply(move_constructor{*this});
    index_ = other.index_;
  }

  variant& operator=(const variant& rhs) {
    rhs.apply(assigner{*this, rhs.index_});
    index_ = rhs.index_;
    return *this;
  }

  variant& operator=(variant&& rhs) noexcept {
    rhs.apply(move_assigner{*this, rhs.index_});
    index_ = rhs.index_;
    return *this;
  }

  /// @returns the index of the active variant type.
  size_t index() const {
    return index_;
  }

  template <class Visitor, class... Args>
  auto apply(Visitor&& visitor, Args&&... args) {
    return visit_impl(index_, storage_, std::forward<Visitor>(visitor),
                      std::forward<Args>(args)...);
  }

  template <class Visitor, class... Args>
  auto apply(Visitor&& visitor, Args&&... args) const {
    return visit_impl(index_, storage_, std::forward<Visitor>(visitor),
                      std::forward<Args>(args)...);
  }

private:
  std::aligned_union_t<0, Ts...> storage_;
  size_t index_;

  struct default_constructor {
    default_constructor(variant& self) : self_(self) {
    }

    template <typename T>
    void operator()(T const&) const {
      self_.construct(T());
    }

  private:
    variant& self_;
  };

  struct copy_constructor {
    copy_constructor(variant& self) : self(self) {
    }

    template <class T>
    void operator()(const T& x) const {
      self.construct(x);
    }

    variant& self;
  };

  struct move_constructor {
    move_constructor(variant& self) : self(self) {
    }

    template <class T>
    void operator()(T& rhs) const noexcept {
      static_assert(std::is_nothrow_move_constructible<T>{},
                    "T must not throw in move constructor");
      self.construct(std::move(rhs));
    }

    variant& self;
  };

  struct assigner {
    template <class Rhs>
    void operator()(const Rhs& rhs) const {
      static_assert(std::is_nothrow_destructible<Rhs>{},
                    "T must not throw in destructor");
      static_assert(std::is_nothrow_move_constructible<Rhs>{},
                    "T must not throw in move constructor");
      if (self.index_ == rhs_index) {
        *reinterpret_cast<Rhs*>(&self.storage_) = rhs;
      } else {
        Rhs tmp(rhs);
        self.destruct();
        self.construct(std::move(tmp));
      }
    }

    variant& self;
    size_t rhs_index;
  };

  template <class T>
  struct container_uses_default_allocator {
    static const bool value = false;
  };

  template <class CharT, class Traits>
  struct container_uses_default_allocator<std::basic_string<CharT, Traits>> {
    static const bool value = true;
  };

  template <class T, class Compare>
  struct container_uses_default_allocator<std::set<T, Compare>> {
    static const bool value = true;
  };

  template <class Key, class T, class Compare>
  struct container_uses_default_allocator<std::map<Key, T, Compare>> {
    static const bool value = true;
  };

  struct move_assigner {
    move_assigner(variant& self, size_t rhs_index)
      : self(self), rhs_index(rhs_index) {
    }

    template <class Rhs>
    void operator()(Rhs& rhs) const noexcept {
      using rhs_type = typename std::remove_const<Rhs>::type;
      static_assert(std::is_nothrow_destructible<rhs_type>{},
                    "T must not throw in destructor");
      static_assert(std::is_nothrow_move_assignable<rhs_type>{} ||
                      // TODO: should be true that these containers only
                      // throw if allocators differ when move assigning?
                      // So for completeness, the static assert should
                      // really be comparing allocator type of this
                      // versus rhs.
                      container_uses_default_allocator<rhs_type>::value,
                    "T must not throw in move assignment");
      static_assert(std::is_nothrow_move_constructible<rhs_type>{},
                    "T must not throw in move constructor");

      if (self.index_ == rhs_index) {
        *reinterpret_cast<rhs_type*>(&self.storage_) = std::move(rhs);
      } else {
        self.destruct();
        self.construct(std::move(rhs));
      }
    }

    variant& self;
    size_t rhs_index;
  };

  template <size_t TT, class... Tail>
  struct initializer;

  template <size_t TT, class T, class... Tail>
  struct initializer<TT, T, Tail...> : public initializer<TT + 1, Tail...> {
    using base = initializer<TT + 1, Tail...>;
    using base::initialize;

    static void initialize(variant& v, T&& x) {
      v.construct(std::move(x));
      v.index_ = TT;
    }

    static void initialize(variant& v, const T& x) {
      v.construct(x);
      v.index_ = TT;
    }
  };

  template <size_t TT>
  struct initializer<TT> {
    void initialize(); // this should never match
  };

  template <class T, class Storage>
  using const_type =
    typename std::conditional<
      std::is_const<std::remove_reference_t<Storage>>::value, T const, T
    >::type;

  template <class T, class Storage, class Visitor, class... Args>
  static auto invoke(Storage&& storage, Visitor&& visitor, Args&&... args) {
    auto x = reinterpret_cast<const_type<T, Storage>*>(&storage);
    return visitor(*x, args...);
  }

  template <class Storage, class Visitor, class... Args>
  static auto visit_impl(size_t idx, Storage&& storage,
                         Visitor&& visitor, Args&&... args) {
    using result_type = decltype(visitor(std::declval<first_type&>(), args...));
    using fn = result_type (*)(Storage&&, Visitor&&, Args&&...);
    static constexpr fn callers[sizeof...(Ts)]
      = {&invoke<Ts, Storage, Visitor, Args...>...};
    VAST_ASSERT(idx >= 0 && idx < sizeof...(Ts));
    return (*callers[idx])(std::forward<Storage>(storage),
                           std::forward<Visitor>(visitor),
                           std::forward<Args>(args)...);
  }

  template <class T>
  void construct(T&& x) noexcept(std::is_rvalue_reference<decltype(x)>{}) {
    using type = std::remove_reference_t<T>;
    static_assert(std::is_nothrow_move_constructible<type>{}
                    || !std::is_rvalue_reference<decltype(x)>{},
                  "move constructor of T must not throw");
    new (&storage_) type(std::forward<T>(x));
  }

  struct dtor {
    template <class T>
    void operator()(T& x) const noexcept {
      static_assert(std::is_nothrow_destructible<T>{},
                    "T must not throw in destructor");
      x.~T();
    }
  };

  void destruct() noexcept {
    apply(dtor{});
  }

  struct equals {
    equals(const variant& self) : self(self) {
    }

    template <class Rhs>
    bool operator()(const Rhs& rhs) const {
      return *reinterpret_cast<const Rhs*>(&self.storage_) == rhs;
    }

    const variant& self;
  };

  struct less_than {
    less_than(const variant& self) : self(self) {
    }

    template <class Rhs>
    bool operator()(const Rhs& rhs) const {
      return *reinterpret_cast<const Rhs*>(&self.storage_) < rhs;
    }

    const variant& self;
  };

  friend bool operator==(const variant& x, const variant& y) {
    return x.index_ == y.index_ && y.apply(equals{x});
  }

  friend bool operator<(const variant& x, const variant& y) {
    if (x.index_ == y.index_)
      return y.apply(less_than{x});
    else
      return x.index_ < y.index_;
  }

  template <class Inspector>
  friend auto inspect(Inspector& f, variant& v) {
    auto save = [&] {
      return visit([&](auto& x) { return f(v.index_, x); }, v);
    };
    auto load = [&] {
      // FIXME: monadically chain return values of inspector invocations. See
      // caf::optional<T> for inspiration.
      f(v.index_);
      auto dispatcher = [&](auto& dummy) {
        using raw_type = std::decay_t<decltype(dummy)>;
        raw_type x;
        auto guard = caf::detail::make_scope_guard(
          [&] { v.construct(std::move(x)); }
        );
        return f(x);
      };
      return visit(dispatcher, v);
    };
    return f(caf::meta::save_callback(save),
             caf::meta::load_callback(load));
  }
};

template <class Visitor>
delayed_visitor<Visitor> visit(Visitor&& visitor) {
  return delayed_visitor<Visitor>(std::move(visitor));
}

template <class Visitor>
delayed_visitor_wrapper<Visitor> visit(Visitor& visitor) {
  return delayed_visitor_wrapper<Visitor>(visitor);
}

template <class Visitor, class Visitable>
auto visit(Visitor&& visitor, Visitable&& visitable) {
  return visitable.template apply(std::forward<Visitor>(visitor));
}

template <class Visitor, class V, class... Vs>
auto visit(Visitor&& visitor, V&& v, Vs&&... vs) {
  return visit(binary_visitor<Visitor, V>(visitor, v), vs...);
}

template <class T>
struct getter {
  T* operator()(T& val) const {
    return &val;
  }

  template <class U>
  T* operator()(const U&) const {
    return nullptr;
  }
};

class bad_variant_access : public std::exception {
public:
  bad_variant_access() = default;

  const char* what() const noexcept override {
    return "bad variant access";
  }
};

template <class T, class... Ts>
T* get_if(variant<Ts...>& v) {
  return visit(getter<T>{}, v);
}

template <class T, class... Ts>
const T* get_if(const variant<Ts...>& v) {
  return visit(getter<const T>{}, v);
}

template <class T, class... Ts>
T& get(variant<Ts...>& v) {
  if (auto ptr = get_if<T>(v))
    return *ptr;
  throw bad_variant_access{};
}

template <class T, class... Ts>
const T& get(const variant<Ts...>& v) {
  if (auto ptr = get_if<const T>(v))
    return *ptr;
  throw bad_variant_access{};
}

template <class T>
struct is_variant : std::false_type {};

template <class... Ts>
struct is_variant<variant<Ts...>> : std::true_type {};

} // namespace detail
} // namespace vast

#endif // VAST_DETAIL_VARIANT_HPP
