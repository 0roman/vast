/*
Copyright (C) 2013 Jarryd Beck (adapated by Matthias Vallentin).

Distributed under the Boost Software License, Version 1.0

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

  The copyright notices in the Software and this entire statement, including
  the above license grant, this restriction and the following disclaimer,
  must be included in all copies of the Software, in whole or in part, and
  all derivative works of the Software, unless such copies or derivative
  works are solely in the form of machine-executable object code generated by
  a source language processor.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
  SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
  FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  DEALINGS IN THE SOFTWARE.

*/

#ifndef VAST_UTIL_VARIANT_H
#define VAST_UTIL_VARIANT_H

#include "vast/util/meta.h"

namespace vast {
namespace util {

template <typename T>
class recursive_wrapper
{
public:
  ~recursive_wrapper()
  {
    delete x_;
  }

  template <
    typename U,
    typename Dummy =
    typename std::enable_if<std::is_convertible<U, T>::value, U>::type
  >
  recursive_wrapper(U const& u)
    : x_(new T(u))
  { }

  template <
    typename U,
    typename Dummy =
    typename std::enable_if<std::is_convertible<U, T>::value, U>::type
  >
  recursive_wrapper(U&& u)
    : x_(new T(std::forward<U>(u)))
  { }

  recursive_wrapper(recursive_wrapper const& rhs)
    : x_(new T(rhs.get())) { }

  recursive_wrapper(recursive_wrapper&& rhs)
    : x_(rhs.x_)
  {
    rhs.x_ = nullptr;
  }

  recursive_wrapper& operator=(recursive_wrapper const& rhs)
  {
    assign(rhs.get());
    return *this;
  }

  recursive_wrapper& operator=(recursive_wrapper&& rhs)
  {
    delete x_;
    x_ = rhs.x_;
    rhs.x_ = nullptr;
    return *this;
  }

  recursive_wrapper& operator=(T const& t)
  {
    assign(t);
    return *this;
  }

  recursive_wrapper&
    operator=(T&& t)
    {
      assign(std::move(t));
      return *this;
    }

  bool operator==(recursive_wrapper const& rhs) const
  {
    return *x_ == *rhs.x_;
  }

  T& get()
  {
    return *x_;
  }

  T const& get() const
  {
    return *x_;
  }

private:
  T* x_;

  template <typename U>
  void assign(U&& u)
  {
    *x_ = std::forward<U>(u);
  }
};

namespace detail {

template <typename T, typename Internal>
T& get_value(T& t, Internal const&)
{
  return t;
}

template <typename T>
T& get_value(recursive_wrapper<T>& t, std::false_type const&)
{
  return t.get();
}

template <typename T>
T const& get_value(recursive_wrapper<T> const& t, std::false_type const&)
{
  return t.get();
}

template <typename Visitor, typename Visitable>
struct BinaryVisitor
{
  using result_type =
    typename std::remove_reference<Visitor>::type::result_type;

  BinaryVisitor(Visitor&& visitor, Visitable&& visitable)
    : v(visitor),
      visitable(visitable)
  {
  }

  template <typename T>
  result_type operator()(T const& t)
  {
    return apply_visitor(v, visitable, t);
  }

private:

  Visitor& v;
  Visitable& visitable;
};

} // namespace detail

template <
  typename Internal,
  typename T,
  typename Storage,
  typename Visitor,
  typename... Args
>
typename std::remove_reference<Visitor>::type::result_type
visitor_caller(Internal&& internal, Storage&& storage, Visitor&& visitor,
               Args&&... args)
{
  using const_type =
    typename std::conditional<
      std::is_const<
        typename std::remove_pointer<
        typename std::remove_reference<Storage>::type
      >::type
     >::value,
     T const,
     T
   >::type;

 return visitor(
     detail::get_value(*reinterpret_cast<const_type*>(storage), internal),
     std::forward<Args>(args)...);
}

template <typename First, typename... Types>
class variant
{
private:
  template <typename... Ts>
  struct do_visit
  {
    template <
      typename Internal,
      typename VoidPtrCV,
      typename Visitor,
      typename... Args
    >
    typename std::remove_reference<Visitor>::type::result_type
    operator()(Internal&& internal,
               size_t which,
               VoidPtrCV&& storage,
               Visitor&& visitor,
               Args&&... args)
    {
      typedef typename std::remove_reference<Visitor>::type::result_type
        (*which_caller)(Internal&&, VoidPtrCV&&, Visitor&&, Args&&...);

      static which_caller callers[sizeof...(Ts)] =
      {
        &visitor_caller<Internal&&, Ts, VoidPtrCV&&, Visitor, Args&&...>...
      };

      assert(which >= 0 && which < sizeof...(Ts));

      return (*callers[which])(
            std::forward<Internal>(internal),
            std::forward<VoidPtrCV>(storage),
            std::forward<Visitor>(visitor),
            std::forward<Args>(args)...);
    }
  };

  template <typename T>
  struct Sizeof
  {
    static constexpr size_t value = sizeof(T);
  };

  template <typename T>
  struct Alignof
  {
    static constexpr size_t value = alignof(T);
  };

  struct constructor
  {
    using result_type = void;

    constructor(variant& self)
      : self_(self)
    {
    }

    template <typename T>
    void operator()(T const& rhs) const
    {
      self_.construct(rhs);
    }

  private:
    variant& self_;
  };

  struct move_constructor
  {
    using result_type = void;

    move_constructor(variant& self)
      : self_(self)
    {
    }

    template <typename T>
    void operator()(T& rhs) const
    {
      self_.construct(std::move(rhs));
    }

  private:
    variant& self_;
  };

  struct assigner
  {
    using result_type = void;

    assigner(variant& self, int rhs_which)
      : self_(self), rhs_which_(rhs_which)
    {
    }

    template <typename Rhs>
    void operator()(Rhs const& rhs) const
    {
      if (self_.which() == rhs_which_)
      {
        //the types are the same, so just assign into the lhs
        *reinterpret_cast<Rhs*>(self_.address()) = rhs;
      }
      else
      {
        Rhs tmp(rhs);
        self_.destroy(); //nothrow
        self_.construct(std::move(tmp)); //nothrow (please)
      }
    }

  private:
    variant& self_;
    int rhs_which_;
  };

  struct move_assigner
  {
    using result_type = void;

    move_assigner(variant& self, int rhs_which)
      : self_(self), rhs_which_(rhs_which)
    {
    }

    template <typename Rhs>
    void operator()(Rhs& rhs) const
    {
      using rhs_no_const = typename std::remove_const<Rhs>::type;

      if (self_.which() == rhs_which_)
      {
        //the types are the same, so just assign into the lhs
        *reinterpret_cast<rhs_no_const*>(self_.address()) = std::move(rhs);
      }
      else
      {
        self_.destroy(); //nothrow
        self_.construct(std::move(rhs)); //nothrow (please)
      }
    }

  private:
    variant& self_;
    int rhs_which_;
  };

  struct equality
  {
    using result_type = bool;

    equality(variant const& self)
      : self_(self)
    {
    }

    template <typename Rhs>
    bool operator()(Rhs& rhs) const
    {
      return *reinterpret_cast<Rhs*>(self_.address()) == rhs;
    }

  private:
    variant const& self_;
  };

  struct destroyer
  {
    using result_type = void;

    template <typename T>
    void operator()(T& x) const
    {
      x.~T();
    }
  };

  template <size_t Which, typename... MyTypes>
  struct initializer;

  template <size_t Which, typename Current, typename... MyTypes>
  struct initializer<Which, Current, MyTypes...>
    : public initializer<Which + 1, MyTypes...>
  {
    using base = initializer<Which + 1, MyTypes...>;
    using base::initialize;

    static void initialize(variant& v, Current&& current)
    {
      v.construct(std::move(current));
      v.indicate_which(Which);
    }

    static void initialize(variant& v, Current const& current)
    {
      v.construct(current);
      v.indicate_which(Which);
    }
  };

  template <size_t Which>
  struct initializer<Which>
  {
    //this should never match
    void initialize();
  };

public:

  variant()
  {
    //try to construct First
    //if this fails then First is not default constructible
    construct(First());
    indicate_which(0);
  }

  ~variant()
  {
    destroy();
  }

  //enable_if disables this function if we are constructing with a variant.
  //Unfortunately, this becomes variant(variant&) which is a better match
  //than variant(variant const& rhs), so it is chosen. Therefore, we disable
  //it.
  template <
    typename T,
    typename Dummy =
    typename std::enable_if<
        ! std::is_same<
          typename std::remove_reference<variant<First, Types...>>::type,
          typename std::remove_reference<T>::type
        >::value,
        T
      >::type
  >
  variant(T&& t)
  {
    static_assert(
        !std::is_same<variant<First, Types...>&, T>::value,
        "why is variant(T&&) instantiated with a variant?");

    //compile error here means that T is not unambiguously convertible to
    //any of the types in (First, Types...)
    initializer<0, First, Types...>::initialize(*this, std::forward<T>(t));
  }

  variant(variant const& rhs)
  {
    rhs.apply_visitor_internal(constructor(*this));
    indicate_which(rhs.which());
  }

  variant(variant&& rhs)
  {
    rhs.apply_visitor_internal(move_constructor(*this));
    indicate_which(rhs.which());
  }

  variant& operator=(variant const& rhs)
  {
    if (this != &rhs)
    {
      rhs.apply_visitor_internal(assigner(*this, rhs.which()));
      indicate_which(rhs.which());
    }
    return *this;
  }

  variant& operator=(variant&& rhs)
  {
    if (this != &rhs)
    {
      rhs.apply_visitor_internal(move_assigner(*this, rhs.which()));
      indicate_which(rhs.which());
    }
    return *this;
  }

  bool operator==(variant const& rhs) const
  {
    if (which() != rhs.which())
    {
      return false;
    }

    return rhs.apply_visitor_internal(equality(*this));
  }

  int which() const {return which_;}

  template <typename Internal, typename Visitor, typename... Args>
  typename std::remove_reference<Visitor>::type::result_type
  apply_visitor(Visitor&& visitor, Args&&... args)
  {
    return do_visit<First, Types...>()(
        Internal(), which_, &storage_,
        std::forward<Visitor>(visitor),
        std::forward<Args>(args)...);
  }

  template <typename Internal, typename Visitor, typename... Args>
  typename std::remove_reference<Visitor>::type::result_type
  apply_visitor(Visitor&& visitor, Args&&... args) const
  {
    return do_visit<First, Types...>()(
        Internal(), which_, &storage_,
        std::forward<Visitor>(visitor),
        std::forward<Args>(args)...);
  }

private:
  using storage_type =
    typename std::aligned_storage<
      max<Sizeof, First, Types...>(),
      max<Alignof, First, Types...>()
     >::type;

  storage_type storage_;
  int which_;

  static std::function<void(void*)> handlers_[1 + sizeof...(Types)];

  void indicate_which(int which)
  {
    which_ = which;
  }

  void* address()
  {
    return &storage_;
  }

  void const* address() const
  {
    return &storage_;
  }

  template <typename Visitor>
  typename Visitor::result_type apply_visitor_internal(Visitor&& visitor)
  {
    return apply_visitor<std::true_type, Visitor>(
        std::forward<Visitor>(visitor));
  }

  template <typename Visitor>
  typename Visitor::result_type
  apply_visitor_internal(Visitor&& visitor) const
  {
    return apply_visitor<std::true_type, Visitor>(
        std::forward<Visitor>(visitor));
  }

  void destroy()
  {
    apply_visitor_internal(destroyer());
  }

  template <typename T>
  void construct(T&& x)
  {
    using type = typename std::remove_reference<T>::type;
    new (&storage_) type(std::forward<T>(x));
  }
};

template <typename T>
struct get_visitor
{
  using result_type = T*;

  result_type operator()(T& x) const
  {
    return &x;
  }

  template <typename U>
  result_type operator()(U const&) const
  {
    return nullptr;
  }
};

template <typename Visitor, typename Visitable, typename... Args>
typename std::remove_reference<Visitor>::type::result_type
apply_visitor(Visitor&& visitor, Visitable&& visitable, Args&&... args)
{
  return visitable.template apply_visitor<std::false_type>(
      std::forward<Visitor>(visitor),
      std::forward<Args>(args)...);
}

template <typename T, typename First, typename... Types>
T* get(variant<First, Types...>& var)
{
  return apply_visitor(get_visitor<T>(), var);
}

template <typename T, typename First, typename... Types>
T const* get(variant<First, Types...> const& var)
{
  return apply_visitor(get_visitor<T const>(), var);
}

struct visitor_applier
{
  template <typename Visitor, typename Visitable, typename... Args>
  auto operator()(Visitor&& visitor, Visitable&& visitable, Args&&... args)
    -> decltype(apply_visitor(
          std::forward<Visitor>(visitor),
          std::forward<Visitable>(visitable),
          std::forward<Args>(args)...))
  {
    return apply_visitor(
          std::forward<Visitor>(visitor),
          std::forward<Visitable>(visitable),
          std::forward<Args>(args)...);
  }
};

template <typename T, typename V>
bool variant_is_type(V const& v)
{
  return get<T>(&v) != nullptr;
}

template <typename Visitor, typename Visitable1, typename Visitable2>
typename std::remove_reference<Visitor>::type::result_type
apply_visitor_binary(Visitor&& visitor, Visitable1&& v1, Visitable2&& v2)
{
  detail::BinaryVisitor<Visitor, Visitable1> v{
    std::forward<Visitor>(visitor),
    std::forward<Visitable1>(v1)
  };

  return apply_visitor(v, std::forward<Visitable2>(v2));
}

} // namespace util
} // namespace vast

#endif
